<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python</title>
      <link href="/2023/01/08/python/"/>
      <url>/2023/01/08/python/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>首先记录一些快捷键：</p><ul><li><code>shift</code>+<code>F10</code>：运行py文件</li></ul><h2 id="python的IO"><a href="#python的IO" class="headerlink" title="python的IO"></a>python的IO</h2><ul><li>输出：<code>print()</code>，例如<code>print(&#39;hello world&#39;)</code>，<code>print()</code>可以接受多个字符串，字符串之间用<code>,</code>隔开，就可以将字符串连成一串输出。<code>print()</code>会依次打印各个字符串，遇到<code>,</code>就会输出一个空格。</li><li>输入：<code>input()</code>，例如<code>name=input()</code>。<code>input()</code>有一个字符串参数，例如<code>name = input(&#39;please enter your name: &#39;)</code>，会首先输出字符串参数的内容。</li></ul><h2 id="python的数据类型"><a href="#python的数据类型" class="headerlink" title="python的数据类型"></a>python的数据类型</h2><ul><li><p>整数：为了清楚，可以在数字中间以<code>_</code>分隔，例如<code>10_000_000_000</code>和<code>10000000000</code>是一样的。</p></li><li><p>字符串：以<code>&#39;</code>或<code>&quot;</code>括起来的任意文本。如果<code>&#39;</code>括起来内部还有<code>&#39;</code>这种的话，就要加转义字符<code>\</code>。python可以用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串不转义。</p></li><li><p>布尔值：只有<code>True</code>和<code>False</code>两种值。可以直接用<code>True</code>和<code>False</code>表示布尔值，也可以通过布尔运算计算出来。布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p></li><li><p>空值：空值用<code>None</code>表示，不能理解为<code>0</code>，<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p></li><li><p><strong>变量：python是动态语言，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。</strong></p></li><li><p>常量：常用大写变量名表示常量，但是这个常量仍然是一个变量，因为python没有任何机制能够保证常量是常量，只是我们自己心里的一个默认罢了。</p></li><li><p><code>list</code>列表：<code>list</code>是一种有序的集合，可以随时添加和删除其中的元素。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li><p>变量<code>classmates</code>就是一个list。用<code>len()</code>函数可以获得list元素的个数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>用索引来访问list中每一个位置的元素，记得索引是从<code>0</code>开始的，最后一个元素的索引是<code>len(classmates) - 1</code>。如果要取最后一个元素，除了计算索引位置外，还可以用<code>-1</code>做索引，直接获取最后一个元素，以此类推，可以获取倒数第2个、倒数第3个。当索引超出了范围时，Python会报一个<code>IndexError</code>错误。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Tracy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">3</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;Tracy&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[-<span class="number">4</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure></li><li><p>list是一个可变的有序表，所以，可以往list中追加元素到末尾。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">&#x27;Adam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>也可以把元素插入到指定的位置，比如索引号为<code>1</code>的位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>要删除list末尾的元素，用<code>pop()</code>方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="string">&#x27;Adam&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">&#x27;Sarah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>list里面的元素的数据类型也可以不同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Apple&#x27;</span>, <span class="number">123</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure></li><li><p>list元素也可以是另一个list。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, [<span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;php&#x27;</span>], <span class="string">&#x27;scheme&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>要注意<code>s</code>只有4个元素，其中<code>s[2]</code>又是一个list，如果拆开写就更容易理解了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = [<span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;php&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, p, <span class="string">&#x27;scheme&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要拿到<code>&#39;php&#39;</code>可以写<code>p[1]</code>或者<code>s[2][1]</code>，因此<code>s</code>可以看成是一个二维数组。</p></li><li><p>如果一个list中一个元素也没有，就是一个空的list，它的长度为0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(L)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>tuple：另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。</p><ul><li><pre><code class="python">&gt;&gt;&gt; classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用`classmates[0]`，`classmates[-1]`，但不能赋值成另外的元素。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来。</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  &gt;&gt;&gt; t = (1, 2)</span><br><span class="line">  &gt;&gt;&gt; t</span><br><span class="line">  (1, 2)</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果要定义一个空的tuple，可以写成<code>()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">()</span><br></pre></td></tr></table></figure></li><li><p>但是，要定义一个只有1个元素的tuple，如果这么定义:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>。</p></li><li><p>一个”可变的“tuple：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>这个tuple定义的时候有3个元素，分别是<code>&#39;a&#39;</code>，<code>&#39;b&#39;</code>和一个list。</p></li></ul></li></ul><img src="/2023/01/08/python/tuple1.png" alt="tuple1" style="zoom:67%;"><p>当我们把list的元素<code>&#39;A&#39;</code>和<code>&#39;B&#39;</code>修改为<code>&#39;X&#39;</code>和<code>&#39;Y&#39;</code>后，tuple变为：</p><p>​<img src="/2023/01/08/python/tuple2.png" alt="tuple2" style="zoom:67%;"></p><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即向<code>&#39;a&#39;</code>，就不能改成指向<code>&#39;b&#39;</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的。</p><p><strong>Python的整数没有大小限制，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</strong></p><h2 id="python的计算"><a href="#python的计算" class="headerlink" title="python的计算"></a>python的计算</h2><ul><li>一种除法是<code>/</code>，<code>/</code>计算结果是浮点数。</li><li>还有一种除法是<code>//</code>，两个整数的除法仍然是整数。</li><li>取余<code>%</code></li></ul><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>python的字符串以Unicode编码，对于单个字符编码，<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符。python对<code>bytes</code>类型的数据用带b前缀的单引号或双引号表示，例如<code>x=b&#39;ABC&#39;</code>。以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法。要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数，<code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>python使用<code>%</code>格式化字符串，有几个<code>%?</code>占位符，后面就跟着几个变量或者值，如果只有一个<code>%?</code>，括号可以省略。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Hello, %s&#x27;</span> % <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="string">&#x27;Michael&#x27;</span>, <span class="number">1000000</span>)</span><br></pre></td></tr></table></figure><p>常见占位符：</p><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><p>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串。有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>。</p><p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">17.125</span>)</span><br><span class="line"><span class="string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一种格式化字符串的方法是使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>&#123;xxx&#125;</code>，就会以对应的变量替换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">2.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="number">3.14</span> * r ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;The area of a circle with radius <span class="subst">&#123;r&#125;</span> is <span class="subst">&#123;s:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">The area of a circle <span class="keyword">with</span> radius <span class="number">2.5</span> <span class="keyword">is</span> <span class="number">19.62</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>&#123;r&#125;</code>被变量<code>r</code>的值替换，<code>&#123;s:.2f&#125;</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>&#123;s:.2f&#125;</code>的替换结果是<code>19.62</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA主成分分析</title>
      <link href="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>PCA就是<strong>降维</strong>保存信息，例如将二维数据保留为一维数据。就是找到一个新的坐标系，这个坐标系的原点落在数据中心，坐标系的方向是往数据分布的方向走。我们需要保存的是新坐标系的原点、新坐标系的角度和新的坐标点。</p><p>PCA的目标就是要找到坐标系，使得保留了某些维度的时候，<strong>信息损失是最小的(信息保留最多)<strong>，比如说投影在某个轴上面，</strong>数据分布是最分散的</strong>。我们要找到数据分布最分散的方向(方差最大)，作为主成分(坐标轴)。新坐标系的第一个维度称为主成分一，第二个维度称为主成分二，如果我们找到数据在主成分一上面的投影分布方差是最大的时候，那么说明主成分一它能够保留最多的信息，在这个时候的坐标系就是最好的坐标系。</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E5%9D%90%E6%A0%87%E8%BD%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="坐标轴示意图"></p><p>如何实现PCA？</p><p>1.首先是要去中心化，就是把坐标原点放在数据的中心。方法就是把每一个值减去全部值的平均值。移动数据并不会改变数据点彼此之间的相对位置。</p><p>2.然后就是找坐标系(找到方差最大的方向) </p><p>我们该如何找到方差最大的方向呢？</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2.png" alt="数据线性变换"></p><p>如果只是数据对角矩阵。用待变换矩阵左乘它就会得到<strong>伸缩</strong>之后的坐标，如图所示就是将x轴拉伸2倍长。原来是单位矩阵左乘，那么是让坐标不变，现在相应的扩大几倍。</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A22.png" alt="数据线性变换2"></p><p>在矩阵运算上面可以想象到，这是逆时针旋转相应度数</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E8%BD%AC%E6%8D%A2.png" alt="转换"></p><p><strong>我们手上的数据就是我们要降维的数据</strong>。可以通过白数据左乘S再左乘R得到。</p><p>拉伸和旋转变换有什么作用？</p><p>拉伸决定了<strong>方差最大的方向</strong>是横或者纵向。旋转决定了方差最大的方向的角度是多大。<strong>所以我们要求的就是R矩阵</strong>。</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E8%BD%AC%E6%8D%A22.png" alt="转换2"></p><p><strong>我们手上的数据</strong>D’同样也可以转换回白数据。可以先乘一个R的逆矩阵，它本来是逆时针旋转，取逆就是再顺时针旋转同样的度数。再拉伸，压缩回拉伸的倒数。</p><p>怎么求R？<strong>协方差矩阵的特征向量就是R</strong>。</p><p>何为协方差矩阵？</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E6%96%B9%E5%B7%AE.png" alt="什么是协方差"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5.png" alt="协方差矩阵"></p><p>白数据x,y不相关，这个时候协方差为0，只剩下对角线，即x、y方差为1就是一个单位矩阵。数据正相关协方差大于0，数据负相关，协方差小于0。</p><p>将协方差的公式代入协方差矩阵得到：再提个1&#x2F;(N-1)</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E4%BB%A3%E5%85%A5%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5.png" alt="代入协方差矩阵"></p><p>这里的D是移至原点后的<strong>原始数据矩阵</strong></p><p>我的想法是C既拉伸又旋转？</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E6%89%8B%E4%B8%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8D%8F%E6%96%B9%E5%B7%AE.png" alt="手上数据的协方差"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F.png" alt="协方差的特征向量"></p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/R和L矩阵.png" alt="R和L矩阵" style="zoom: 80%;"><p>把特征值放到一起组成L矩阵，把特征向量v1和v2组合到一起成为R</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC.png" alt="协方差的特征值"></p><p>旋转回来协方差是L，因为R逆是一个对角矩阵，旋转回来之后x方向和y方向不相关，x方向的方差是a²，y方向的方差是b²，同时又是协方差矩阵的特征值。</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3PCA.png" alt="如何求解PCA"></p><p>如何判断PCA拟合度的高低？我们可以通过量化数据在主成分上的投影长度和最小或者数据在投影点到中心点的距离和最大，通常我们选择后者，因为后者更方便。</p><p>计算每个主成分的差异率就是把主成分分别的特征值除以全部的特征值加起来，越大越好，代表信息越多</p><p>主成分分析的应用</p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E4%B8%A4%E7%BB%84%E6%95%B0%E6%8D%AE.png" alt="两组数据"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E7%82%B9%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96.png" alt="样本点去中心化"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E7%BB%98%E5%9B%BE.png" alt="绘图"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/%E5%8E%9F%E6%9C%89%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E7%BB%B4%E6%95%B0%E6%8D%AE.png" alt="原有数据转化为一维数据"></p><p><img src="/2023/01/05/PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/PCA%E6%AD%A5%E9%AA%A4.png" alt="PCA步骤"></p><p>主成分分析的本质就是向量换基。</p><p>主成分分析通过对投影距离方差的运用将降维问题转换成了求最值的问题。</p><p>PCA还有其他的实现方法，例如使用相关矩阵代替协方差矩阵，也可以使用奇异值分解(SVD)，但是原理类似。</p><p>如果让输入数据矩阵维度在行上，观测值在列上，推导可能会更简洁一些(特征向量不用转置)，但是不影响结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Action</title>
      <link href="/2022/12/30/Action/"/>
      <url>/2022/12/30/Action/</url>
      
        <content type="html"><![CDATA[<h2 id="上传一个文件到博客的步骤如下："><a href="#上传一个文件到博客的步骤如下：" class="headerlink" title="上传一个文件到博客的步骤如下："></a>上传一个文件到博客的步骤如下：</h2><h3 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="生成新的静态文件"><a href="#生成新的静态文件" class="headerlink" title="生成新的静态文件"></a>生成新的静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="本地预览博客"><a href="#本地预览博客" class="headerlink" title="本地预览博客"></a>本地预览博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="上传到github仓库，将文件部署到博客上"><a href="#上传到github仓库，将文件部署到博客上" class="headerlink" title="上传到github仓库，将文件部署到博客上"></a>上传到github仓库，将文件部署到博客上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="其他的一些设置："><a href="#其他的一些设置：" class="headerlink" title="其他的一些设置："></a>其他的一些设置：</h2><h3 id="生成新的md文件"><a href="#生成新的md文件" class="headerlink" title="生成新的md文件"></a>生成新的md文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo n</span><br></pre></td></tr></table></figure><h2 id="butterfly设置："><a href="#butterfly设置：" class="headerlink" title="butterfly设置："></a>butterfly设置：</h2><h3 id="创建一个新的标签页"><a href="#创建一个新的标签页" class="headerlink" title="创建一个新的标签页"></a>创建一个新的标签页</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><h3 id="创建一个分类页"><a href="#创建一个分类页" class="headerlink" title="创建一个分类页"></a>创建一个分类页</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><h3 id="创建友情链接"><a href="#创建友情链接" class="headerlink" title="创建友情链接"></a>创建友情链接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="built_in">link</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 技术操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN</title>
      <link href="/2022/12/30/CNN/"/>
      <url>/2022/12/30/CNN/</url>
      
        <content type="html"><![CDATA[<p><strong>卷积神经网络用处在哪？</strong></p><p>卷积神经网络是用于特征提取的。</p><p>传统的神经网络权重参数矩阵大、训练时间多、过拟合风险高。</p><p>可用于检测追踪任务、分类和检索、超分辨率重构、无人驾驶、人脸识别等</p><img src="/2022/12/30/CNN/超分辨率.png" alt="超分辨率" style="zoom:50%;"><p><strong>卷积神经网络(CNN)与传统网络(NN)的区别：</strong></p><img src="/2022/12/30/CNN/卷积神经网络与传统网络的区别.png" alt="卷积神经网络与传统网络的区别" style="zoom: 80%;"><ul><li>NN输入的是像素点，而CNN输入的是一张原始图像(h×w×c)，一个是一维，一个是三维。</li></ul><p><strong>卷积神经网络的整体架构：</strong></p><ul><li>输入层：输入一个图像数据</li><li>卷积层：尽可能多的提取特征</li><li>池化层：压缩、下采样特征</li><li>全连接层：通过一组权重参数，把输入层和输出层连在一起</li></ul><p><strong>卷积：</strong>卷积做了一件什么事？</p><img src="/2022/12/30/CNN/卷积做了一件什么事.png" alt="卷积做了一件什么事" style="zoom:60%;"><p>对不同的区域提取出不同的特征，将一张图像分成不同的部分，区别处理，进行图像分割。</p><p><strong>图像颜色通道</strong>：</p><p>R,G,B：要对三个颜色通道分别做计算，把三个通道卷积完的结果<strong>加</strong>在一起。对于每一个区域都要进行特征提取，得到最终的特征值。</p><img src="/2022/12/30/CNN/RGB特征提取.png" alt="RGB特征提取" style="zoom:67%;"><p>输入的图像维度c是多少，那么卷积核的维度c也应该是多少。</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积核就是：每多大区域选出一个特征，一个区域对应出一个特征值。 相当于权重，刚开始是随机初始化的，然后学习更新。即下图W0</p><p>所有的卷积网络都是用<strong>内积</strong>做计算，<strong>对应位置相乘</strong>，所有结果加一起就可以了。结果别忘了加一个偏置项。在每一个卷积层中的特征矩阵w,h应该是相同的。在不通的卷积层中w,h可以不同</p><p><img src="/2022/12/30/CNN/%E5%8D%B7%E7%A7%AF%E8%BF%87%E7%A8%8B.png" alt="卷积过程"></p><p><img src="/2022/12/30/CNN/%E5%8D%B7%E7%A7%AF%E8%BF%87%E7%A8%8B2.png" alt="卷积过程2"></p><p><strong>卷积层涉及的参数</strong>：</p><ul><li><p>滑动窗口步长：注意<strong>步长</strong>为2得到的最终结果才是3*3，步长小，提取特征比较细致，效率慢；步长大，提取特征比较粗糙，特征少。<strong>一般对于图像而言，我们选择步长为1就可以</strong>，但是对于文本数据和其他数据步长不确定。</p></li><li><p>卷积核尺寸：卷积核越小，特征提取越细致，一般来说选<strong>3*3</strong></p></li><li><p>边缘填充：在边界外再加几圈0，能够弥补一些边界信息利用不充分问题。最外层只是扩充，因为是0，所以对最终结果不会产生影响。一般添一圈</p></li><li><p>卷积核个数：在算的过程当中要得到多少个特征图就有多少个卷积核。</p></li></ul><p>特征图的个数：特征图的个数取决于你给了多少份的权重矩阵，选择不通的权重矩阵，得到的特征图个数结果不一样。</p><p>卷积神经网络不止可以做一次卷积，一次可以提取出粗略特征，再卷积一次可以提取出中间特征，最后再提取出高级特征，再拿出高级特征来做分类。做一次卷积是不够的，需要做多次。</p><p><strong>卷积结果计算公式：</strong></p><img src="/2022/12/30/CNN/卷积结果计算公式.png" alt="卷积结果计算公式" style="zoom:80%;"><img src="/2022/12/30/CNN/卷积结果计算例子.png" alt="卷积结果计算例子" style="zoom: 33%;"><p><strong>卷积参数共享：</strong></p><p> 对于图中的每个区域都选择同样的卷积核，卷积核这个权值矩阵是不变的</p><p><img src="/2022/12/30/CNN/%E5%8F%82%E6%95%B0%E5%85%B1%E4%BA%AB.png" alt="参数共享"></p><p>每次卷积完都要加一个RELU函数，即非线性变换</p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>在原始得到的特征上进行一个筛选，并不会改变特征图的个数。不涉及矩阵计算，只涉及筛选。</p><p><strong>最大池化</strong>：</p><p>选择不同区域，在每个区域中选择最大值，选择一个最大值说明这个特征比较重要。</p><img src="/2022/12/30/CNN/最大池化.png" alt="最大池化" style="zoom: 67%;"><p><strong>平均池化</strong>：</p><p>选择不同区域，在每个区域中求平均值。</p><p>我们<strong>选择最大池化</strong>，因为神经网络是个优胜劣汰的过程，我们选择最好的特征，不平均来把不好的特征拷进去。</p><p>两次卷积后一次池化，RELU是激活函数</p><p><img src="/2022/12/30/CNN/%E5%8D%B7%E7%A7%AF%E6%B1%A0%E5%8C%96.png" alt="卷积池化"></p><p>卷积和池化只是做特征提取的，到最后池化后会形成立体的特征图，对特征图进行分类，如何转化为分类的概率值？全连接层无法连三维的东西，我们需要将三维的特征图拉长形成特征向量，全连接层如果是五分类，池化层得到的特征图大小为<code>32*32*10</code>，那么得到的全连接层是[10240,5]，相当于将10240个特征转化为我们预测的五个类别的概率值。所以在Pooling层和FC层之间还有一个拉长的操作（转换操作）</p><p><strong>什么才能称为一层</strong>？带参数计算的才能被称为一层。卷积层带，RELU层(激活层)不带参数计算，池化层不带参数计算，不更新参数之类的，全连接层也有权重参数矩阵，需要更新参数。</p><img src="/2022/12/30/CNN/特征图的变化.png" alt="特征图的变化" style="zoom:67%;"><p><strong>感受野：</strong></p><img src="/2022/12/30/CNN/感受野.png" alt="感受野" style="zoom:60%;"><p>我们希望感受野越大越好。</p><img src="/2022/12/30/CNN/感受野2.png" alt="感受野2" style="zoom:60%;">]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
